Strings shows something interesting:

.rdata:100054A4 aAplibV1_01TheS db 'aPLib v1.01  -  the smaller the better :)',0Dh,0Ah
.rdata:100054A4                 db 'Copyright (c) 1998-2009 by Joergen Ibsen, All Rights Reserved.',0Dh,0Ah
.rdata:100054A4                 db 0Dh,0Ah
.rdata:100054A4                 db 'More information: http://www.ibsensoftware.com/',0Dh,0Ah
.rdata:100054A4                 db 0Dh,0Ah,0

From the site:

"The main product available here is the aPLib compression library, which I started working on back in 1997 as a part of my executable compressor aPACK. Since it's first public release in 1998 it has ranged as one of the best pure LZ-based compression libraries available."

Main function:

.text:100013A0 DllEntryPoint   proc near
.text:100013A0
.text:100013A0 hModule         = dword ptr  8
.text:100013A0 fdwReason       = dword ptr  0Ch
.text:100013A0 lpReserved      = dword ptr  10h
.text:100013A0
.text:100013A0                 push    ebp
.text:100013A1                 mov     ebp, esp
.text:100013A3                 cmp     [ebp+fdwReason], DLL_PROCESS_ATTACH
.text:100013A7                 jnz     short loc_100013B2
.text:100013A9                 push    [ebp+hModule]   ; hModule
.text:100013AC                 call    do_stuff
.text:100013B1                 pop     ecx
.text:100013B2
.text:100013B2 loc_100013B2:                           ; CODE XREF: DllEntryPoint+7j
.text:100013B2                 xor     eax, eax
.text:100013B4                 pop     ebp
.text:100013B5                 retn    0Ch
.text:100013B5 DllEntryPoint   endp

do_stuff calls a lot of other functions, but the first one caught my eye:

.text:10001C2E ; int __cdecl sub_10001C2E(HMODULE hModule, int)
.text:10001C2E sub_10001C2E    proc near               ; CODE XREF: do_stuff+12p
.text:10001C2E
.text:10001C2E hModule         = dword ptr  8
.text:10001C2E arg_4           = dword ptr  0Ch
.text:10001C2E
.text:10001C2E                 push    ebp
.text:10001C2F                 mov     ebp, esp
.text:10001C31                 push    esi
.text:10001C32                 push    0Ah             ; lpType
.text:10001C34                 push    65h             ; lpName
.text:10001C36                 push    [ebp+hModule]   ; hModule
.text:10001C39                 call    ds:FindResourceA
.text:10001C3F                 mov     esi, eax
.text:10001C41                 test    esi, esi
.text:10001C43                 jz      short loc_10001C9E
.text:10001C45                 push    edi
.text:10001C46                 push    esi             ; hResInfo
.text:10001C47                 push    [ebp+hModule]   ; hModule
.text:10001C4A                 call    ds:SizeofResource
.text:10001C50                 mov     edi, eax
.text:10001C52                 test    edi, edi
.text:10001C54                 jz      short loc_10001C9D
.text:10001C56                 push    ebx
.text:10001C57                 push    esi             ; hResInfo
.text:10001C58                 push    [ebp+hModule]   ; hModule
.text:10001C5B                 call    ds:LoadResource
.text:10001C61                 mov     ebx, eax
.text:10001C63                 test    ebx, ebx
.text:10001C65                 jz      short loc_10001C9C
.text:10001C67                 push    ebx             ; hResData
.text:10001C68                 call    ds:LockResource
.text:10001C6E                 mov     esi, eax
.text:10001C70                 test    esi, esi
.text:10001C72                 jnz     short loc_10001C78

FindResourceA: Determine location of PE resource

SizeofResource: Get its size

LoadResource: Get a handle to it

LockResource: Get the data from it

Let's be lazy: get http://www.heaventools.com/overview.htm PE Explorer

Extract "Resource 101"

$ xxd -g1 stage4_compressed.bin | head
0000000: 41 50 33 32 18 00 00 00 a1 c9 01 00 0b e4 d7 66  AP32...........f
0000010: 0b 51 03 00 f2 8d 91 b3 0b 38 51 03 1c 49 01 38  .Q.......8Q..I.8
0000020: 37 b7 0e 0f 8c 07 09 7b d0 1a 01 be bc 55 1c 8b  7......{.....U..
...

Between "aPLib v1.01" and the "AP32" header, it sure seems compressed! We have to figure out how to decompress it...

Download http://ibsensoftware.com/files/aPLib-1.01.zip

Find appack.exe

$ ./appack.exe d ./stage4_compressed.bin  stage4.bin
===============================================================================
aPLib example                   Copyright (c) 1998-2009 by Joergen Ibsen / Jibz
                                                            All Rights Reserved

                                                  http://www.ibsensoftware.com/
===============================================================================

decompressed 117177 -> 217355 bytes in 0.00 seconds

(note: path stuff is super sketchy, might have to move it into the same folder)

The file looks like:

0000000: 0b 51 03 00 49 01 00 00 b7 03 00 00 0b 07 00 00  .Q..I...........
0000010: 0b 7b 01 00 00 00 00 00 00 00 00 00 00 00 00 00  .{..............
0000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
...

Definitely not compressed/encrypted, at least! There's a reference to "MZ" at the top, but it's not "MZ[90][00]" like it should be! At index 0x70b, however, we see the familiar MZ[90][00]. Grab just that portion...

We remove the first 0x70a bytes, load it in IDA, and Voila! A .dll file that has registry access, calls Internet functions, and so on. I think we found the actual payload!

Also in the payload, I notice at index 0x0c, I see 0b 07, or 0x070b - the index of the PE start. Right after that, I see 0b 7b 01 - 0x17b0b. If I fast forward to that offset, I see another MZ! So this actually packs multiple payloads!

That makes me wonder, so I look at the payload as a series of 32-bit values:

$ xxd -g1 stage4_unk.bin | head
0000000: 0b 51 03 00 49 01 00 00 b7 03 00 00 0b 07 00 00  .Q..I...........
0000010: 0b 7b 01 00 00 00 00 00 00 00 00 00 00 00 00 00  .{..............

0x0003510b - the length of the entire file
0x00000149 - at this offset, there's some raw code - 55 8b ... (a raw binary function) - I initially assumed a 16-bit version, but that doesn't seem likely
0x000003b7 - at this offset, nothing special, but it appears to be code. Not sure what its deal is...
0x0000070b - A proper MZ file, that we already found
0x00017b0b - Another MZ file - I guessed that this is a 64-bit version of the same thing, which seems likely - upon inspection, it has the same imports/strings
0x00000000
...

0x149 - Somehow involved with loading a PE file. Looks for "MZ" and "PE" in a string it's passed. It also calls pointers from the string it's passed. Seems likely that it loads/runs a .dll in a stand-alone way.

Back to the original .dll file...

I see CreateRemoteThread - likely uses injection to load a .dll into another process

To explore this better, need to use dynamic analysis. Fix the main function:

.text:100013A0                   ; BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
.text:100013A0                                   public DllEntryPoint
.text:100013A0                   DllEntryPoint   proc near
.text:100013A0
.text:100013A0                   hModule         = dword ptr  8
.text:100013A0                   fdwReason       = dword ptr  0Ch
.text:100013A0                   lpReserved      = dword ptr  10h
.text:100013A0
.text:100013A0 55                                push    ebp
.text:100013A1 8B EC                             mov     ebp, esp
.text:100013A3 83 7D 0C 01                       cmp     [ebp+fdwReason], DLL_PROCESS_ATTACH
.text:100013A7 75 09                             jnz     short loc_100013B2
.text:100013A9 FF 75 08                          push    [ebp+hModule]   ; hModule
.text:100013AC E8 72 FF FF FF                    call    do_stuff
.text:100013B1 59                                pop     ecx
.text:100013B2
.text:100013B2                   loc_100013B2:                           ; CODE XREF: DllEntryPoint+7j
.text:100013B2 33 C0                             xor     eax, eax
.text:100013B4 5D                                pop     ebp
.text:100013B5 C2 0C 00                          retn    0Ch
.text:100013B5                   DllEntryPoint   endp

Remove the call to do_stuff:

.text:100013A0                   ; BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
.text:100013A0                                   public DllEntryPoint
.text:100013A0                   DllEntryPoint   proc near
.text:100013A0
.text:100013A0                   hinstDLL        = dword ptr  8
.text:100013A0                   fdwReason       = dword ptr  0Ch
.text:100013A0                   lpReserved      = dword ptr  10h
.text:100013A0
.text:100013A0 55                                push    ebp
.text:100013A1 8B EC                             mov     ebp, esp
.text:100013A3 83 7D 0C 01                       cmp     [ebp+fdwReason], 1
.text:100013A7 75 09                             jnz     short loc_100013B2
.text:100013A9 FF 75 08                          push    [ebp+hinstDLL]
.text:100013AC CD 03                             int     3               ; - software interrupt to invoke the debugger
.text:100013AE 90                                nop
.text:100013AF 90                                nop
.text:100013B0 90                                nop
.text:100013B1 59                                pop     ecx
.text:100013B2
.text:100013B2                   loc_100013B2:                           ; CODE XREF: DllEntryPoint+7j
.text:100013B2 33 C0                             xor     eax, eax
.text:100013B4 5D                                pop     ebp
.text:100013B5 C2 0C 00                          retn    0Ch
.text:100013B5                   DllEntryPoint   endp

Now I can safely load/debug it! It takes a little doing in the debugger to get it going, but I'm totally fine with jumping through hoops since this is dangerous work...

Get the resource from the PE resources section:

.text:10001331 50                                push    eax             ; ptrBuffer
.text:10001332 FF 75 08                          push    [ebp+hModule]   ; hModule
.text:10001335 E8 F4 08 00 00                    call    ReadResource    ; eax becomes a pointer to the buffer

Decompress it:

.text:10001340 8B 74 24 0C                       mov     esi, [esp+10h+ptrBuffer]
.text:10001344 8D 7C 24 0C                       lea     edi, [esp+10h+ptrBuffer]
.text:10001348 8B C8                             mov     ecx, eax
.text:1000134A E8 52 09 00 00                    call    Decompress      ; esi = ptr to the AP32 file
.text:1000134A                                                           ; edi = a pointer to a string pointer that will get the decrypted data

Free the compressed version:

.text:1000134F 56                                push    esi             ; lpMem
.text:10001350 8B F8                             mov     edi, eax
.text:10001352 E8 38 0B 00 00                    call    HeapFreeWrapper ; Free the compressed data

Load a bunch of pointers to kernel32 or kernelbase functions depending on os version (wow!)

Does a bunch of other setup type stuff, but it looks like the magic happens in sub_10001051...

- Get the HDD serial number

This code:

.text:100016C4 69 C0 FD 43 03 00                 imul    eax, 343FDh
.text:100016CA 05 C3 9E 26 00                    add     eax, 269EC3h

Which, by googling the constants, I determined is a PRNG

Uses that to generate a filename, presumably writes the data to that file (I can't find that code, but I didn't look in detail), then uses CreateRemoteThread to start it in any other process it can.
