stage2.bin....

Load into IDA as a 'Binary File' in 32-bit mode

Go through and find chunks that look like functions, define them with 'p'

Notice some interesting stuff:

seg000:0000040E                 db  54h ; T
seg000:0000040F                 db  68h ; h
seg000:00000410                 db  69h ; i
seg000:00000411                 db  73h ; s
seg000:00000412                 db  20h
seg000:00000413                 db  0Eh
seg000:00000414                 db  70h ; p
seg000:00000415                 db  72h ; r
seg000:00000416                 db  6Fh ; o
seg000:00000417                 db  67h ; g
seg000:00000418                 db  67h ; g
seg000:00000419                 db  61h ; a
seg000:0000041A                 db  6Dh ; m
seg000:0000041B                 db  87h ; ç
seg000:0000041C                 db  63h ; c
seg000:0000041D                 db  47h ; G
seg000:0000041E                 db  6Eh ; n

Looks like a PE header?

Anyway, back to the starting function... you have to carefully define/undefine code, since code and data are mixed!

Eventually wind up with:

seg000:00000000                 push    ebp             ; Standard function prefix
seg000:00000001                 mov     ebp, esp
seg000:00000003                 sub     esp, 4          ; 4 bytes for local variables
seg000:00000006                 push    esi
seg000:00000007                 push    edi
seg000:00000008                 push    ebx
seg000:00000009                 call    $+5
seg000:0000000E                 pop     ebx
seg000:0000000F                 sub     ebx, 40100Eh
seg000:00000015                 mov     eax, dword ptr fs:loc_2C+4
seg000:0000001B                 mov     eax, [eax+0Ch]
seg000:0000001E                 mov     eax, [eax+1Ch]
seg000:00000021
seg000:00000021 loc_21:                                 ; CODE XREF: seg000:0000002Aj
seg000:00000021                 mov     esi, [eax+8]
seg000:00000024                 cmp     byte ptr [eax+1Ch], 18h
seg000:00000028                 mov     eax, [eax]
seg000:0000002A                 jnz     short loc_21
seg000:0000002C
seg000:0000002C loc_2C:                                 ; DATA XREF: seg000:00000015r
seg000:0000002C                                         ; sub_2E5+4r
seg000:0000002C                 call    loc_40
seg000:0000002C ; ---------------------------------------------------------------------------
seg000:00000031 aGetProcAddress db 'GetProcAddress',0
seg000:00000040 ; ---------------------------------------------------------------------------
seg000:00000040
seg000:00000040 loc_40:                                 ; CODE XREF: seg000:loc_2Cp
seg000:00000040                 push    esi
seg000:00000041                 call    sub_188
seg000:00000046                 mov     [ebx+4013BCh], eax
seg000:0000004C                 call    loc_5E
seg000:0000004C ; ---------------------------------------------------------------------------
seg000:00000051 aLoadlibrarya   db 'LoadLibraryA',0
seg000:0000005E ; ---------------------------------------------------------------------------
seg000:0000005E
seg000:0000005E loc_5E:                                 ; CODE XREF: seg000:0000004Cp
seg000:0000005E                 push    esi
seg000:0000005F                 call    dword ptr [ebx+4013BCh]
seg000:00000065                 mov     [ebx+4013C0h], eax
seg000:0000006B                 call    loc_80
seg000:0000006B ; ---------------------------------------------------------------------------
seg000:00000070 aUnmapviewoffile db 'UnmapViewOfFile',0
seg000:00000080 ; ---------------------------------------------------------------------------
seg000:00000080
seg000:00000080 loc_80:                                 ; CODE XREF: seg000:0000006Bp
seg000:00000080                 push    esi
seg000:00000081                 call    dword ptr [ebx+4013BCh]
seg000:00000087                 mov     [ebx+4013C4h], eax
seg000:0000008D                 call    loc_9F
seg000:0000008D ; ---------------------------------------------------------------------------
seg000:00000092 aVirtualalloc   db 'VirtualAlloc',0
seg000:0000009F ; ---------------------------------------------------------------------------
seg000:0000009F
seg000:0000009F loc_9F:                                 ; CODE XREF: seg000:0000008Dp
seg000:0000009F                 push    esi
seg000:000000A0                 call    dword ptr [ebx+4013BCh]
seg000:000000A6                 mov     [ebx+4013C8h], eax
seg000:000000AC                 call    loc_BD
seg000:000000AC ; ---------------------------------------------------------------------------
seg000:000000B1 aVirtualfree    db 'VirtualFree',0
seg000:000000BD ; ---------------------------------------------------------------------------
seg000:000000BD
seg000:000000BD loc_BD:                                 ; CODE XREF: seg000:000000ACp
seg000:000000BD                 push    esi
seg000:000000BE                 call    dword ptr [ebx+4013BCh]
seg000:000000C4                 mov     [ebx+4013CCh], eax
seg000:000000CA
seg000:000000CA loc_CA:                                 ; CODE XREF: seg000:000000E0j
seg000:000000CA                 push    4
seg000:000000CC                 push    3000h
seg000:000000D1                 push    0A00000h
seg000:000000D6                 push    0
seg000:000000D8                 call    dword ptr [ebx+4013C8h]
seg000:000000DE                 test    eax, eax
seg000:000000E0                 jz      short loc_CA
seg000:000000E2                 mov     [ebp-4], eax
seg000:000000E5                 push    eax
seg000:000000E6                 lea     eax, [ebx+4013D0h]
seg000:000000EC                 mov     ecx, [eax+4]
seg000:000000EF                 add     eax, ecx
seg000:000000F1                 push    eax
seg000:000000F2                 call    sub_313
seg000:000000F7                 pop     eax
seg000:000000F8                 pop     eax
seg000:000000F9                 mov     esi, [ebp-4]
seg000:000000FC                 add     esi, [esi+3Ch]
seg000:000000FF                 mov     edi, [esi+34h]
seg000:00000102                 mov     eax, [ebp+10h]
seg000:00000105                 test    eax, eax
seg000:00000107                 jnz     short loc_114
seg000:00000109                 mov     eax, [ebp+0Ch]
seg000:0000010C                 dec     eax
seg000:0000010D                 test    eax, eax
seg000:0000010F                 jnz     short loc_114
seg000:00000111                 mov     edi, [ebp+8]
seg000:00000114
seg000:00000114 loc_114:                                ; CODE XREF: seg000:00000107j
seg000:00000114                                         ; seg000:0000010Fj
seg000:00000114                 push    edi
seg000:00000115                 call    dword ptr [ebx+4013C4h]
seg000:0000011B                 mov     eax, [esi+50h]
seg000:0000011E                 push    40h ; '@'
seg000:00000120                 push    3000h
seg000:00000125                 push    eax
seg000:00000126                 push    edi
seg000:00000127                 call    dword ptr [ebx+4013C8h]
seg000:0000012D                 mov     ecx, [esi+54h]
seg000:00000130                 mov     esi, [ebp-4]
seg000:00000133                 rep movsb
seg000:00000135                 mov     edi, eax
seg000:00000137                 push    dword ptr [ebp-4]
seg000:0000013A                 push    edi
seg000:0000013B                 call    sub_1E9
seg000:00000140                 push    edi
seg000:00000141                 call    sub_219
seg000:00000146                 push    edi
seg000:00000147                 call    sub_28A
seg000:0000014C                 push    8000h
seg000:00000151                 push    0
seg000:00000153                 push    dword ptr [ebp-4]
seg000:00000156                 call    dword ptr [ebx+4013CCh]
seg000:0000015C                 mov     eax, [ebx+4013CCh]
seg000:00000162                 lea     ecx, [ebx+401000h]
seg000:00000168                 mov     edx, [edi+3Ch]
seg000:0000016B                 add     edx, edi
seg000:0000016D                 mov     edx, [edx+28h]
seg000:00000170                 add     edx, edi
seg000:00000172                 push    edx
seg000:00000173                 push    edi
seg000:00000174                 call    sub_2E5
seg000:00000179                 pop     ebx
seg000:0000017A                 pop     edi
seg000:0000017B                 pop     esi
seg000:0000017C                 leave
seg000:0000017D                 push    8000h
seg000:00000182                 push    0
seg000:00000184                 push    ecx
seg000:00000185                 push    edx
seg000:00000186                 jmp     eax

Note: I re-based to 3b0000 to match my disassembler

Get a handle to kernel32.dll:

seg000:003B0015                 mov     eax, large fs:30h ; This section basically gets a handle to kernel32.dll
seg000:003B001B                 mov     eax, [eax+0Ch]
seg000:003B001E                 mov     eax, [eax+1Ch]
seg000:003B0021
seg000:003B0021 loc_3B0021:                             ; CODE XREF: seg000:003B002Aj
seg000:003B0021                 mov     esi, [eax+8]
seg000:003B0024                 cmp     byte ptr [eax+1Ch], 18h
seg000:003B0028                 mov     eax, [eax]
seg000:003B002A                 jnz     short loc_3B0021 ; When this ends, esi = handle to kernel32.dll

Get the address of GetProcAddress:

seg000:003B002C loc_3B002C:
seg000:003B002C                 call    loc_3B0040
seg000:003B002C ; ---------------------------------------------------------------------------
seg000:003B0031 aGetProcAddress db 'GetProcAddress',0
seg000:003B0040 ; ---------------------------------------------------------------------------
seg000:003B0040
seg000:003B0040 loc_3B0040:                             ; CODE XREF: seg000:loc_3B002Cp
seg000:003B0040                 push    esi             ; addr of kernel32.dll
seg000:003B0041                 call    find_function
seg000:003B0046                 mov     [ebx+test.addr_GetProcAddress], eax

seg000:003B004C                 call    loc_3B005E
seg000:003B004C ; ---------------------------------------------------------------------------
seg000:003B0051 aLoadlibrarya   db 'LoadLibraryA',0
seg000:003B005E ; ---------------------------------------------------------------------------
seg000:003B005E
seg000:003B005E loc_3B005E:                             ; CODE XREF: seg000:003B004Cp
seg000:003B005E                 push    esi
seg000:003B005F                 call    [ebx+test.addr_GetProcAddress]
seg000:003B0065                 mov     [ebx+test.addr_LoadLibraryA], eax

Basically gets handles to:
- GetProcAddress
- LoadLibraryA
- UnmapViewOfFile
- VirtualAlloc
- VirtualFree

Allocat memory, and keep looping till it works:

seg000:003B00CA loc_3B00CA:                             ; CODE XREF: seg000:003B00E0j
seg000:003B00CA                 push    4               ; flProtect = PAGE_READWRITE
seg000:003B00CC                 push    3000h           ; flAllocationType = MEM_RESERVE | MEM_COMMIT
seg000:003B00D1                 push    0A00000h        ; dwSize = 10,485,760 bytes
seg000:003B00D6                 push    0               ; lpAddress
seg000:003B00D8                 call    [ebx+test.addr_VirtualAlloc]
seg000:003B00DE                 test    eax, eax
seg000:003B00E0                 jz      short loc_3B00CA

Then:

seg000:003B00E2                 mov     [ebp-4], eax    ; ebp-4 = allocated memory
seg000:003B00E5                 push    eax             ; allocated memory
seg000:003B00E6                 lea     eax, [ebx+test.field_4013D0] ; eax = ptr to encrypted data (003b03d0)
seg000:003B00EC                 mov     ecx, [eax+4]
seg000:003B00EF                 add     eax, ecx
seg000:003B00F1                 push    eax             ; Looks like start of obfuscated PE file (003b03e8)
seg000:003B00F2                 call    sub_3B0313      ; Complicated but looks harmless

The first argument - start of obfuscated PE file - looks like:

seg000:003B03E8                 db  4Dh ; M
seg000:003B03E9                 db  38h ; 8
seg000:003B03EA                 db  5Ah ; Z
seg000:003B03EB                 db  90h ; É
seg000:003B03EC                 db  38h ; 8
seg000:003B03ED                 db    3
seg000:003B03EE                 db  66h ; f
...

A proper PE file should start with MZ\x90\x00. Since Part1 handled nulls specially, this likely does as well.

I (perhaps unwisely) let sub_3b0313 run in a VM, and it returns 0x20a00 (a size?). The allocated memory is now interesting:

0:000> db 900000
00900000  4d 5a 90 00 03 00 00 00-04 00 00 00 ff ff 00 00  MZ..............
00900010  b8 00 00 00 00 00 00 00-40 00 00 00 00 00 00 00  ........@.......
00900020  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
00900030  00 00 00 00 00 00 00 00-00 00 00 00 e8 00 00 00  ................
00900040  0e 1f ba 0e 00 b4 09 cd-21 b8 01 4c cd 21 54 68  ........!..L.!Th
00900050  69 73 20 70 72 6f 67 72-61 6d 20 63 61 6e 6e 6f  is program canno
00900060  74 20 62 65 20 72 75 6e-20 69 6e 20 44 4f 53 20  t be run in DOS 
00900070  6d 6f 64 65 2e 0d 0d 0a-24 00 00 00 00 00 00 00  mode....$.......

A PE! 

If I index it with eax, I see:

0:000> db 900000+eax-0x70
00920990  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
009209a0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
009209b0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
009209c0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
009209d0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
009209e0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
009209f0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
00920a00  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................

So thinking that's a length might just be right! I dump the file to see if IDA recognizes it:

0:000> .writemem "c:\\stage3.bin" 0x900000 L0x00020a00 
Writing 20a00 bytes..................................................................

When I open it in IDA, it works great! It's a .dll file, and it has interesting looking imports, exports, and strings:

.rdata:100054A4 aAplibV1_01TheS db 'aPLib v1.01  -  the smaller the better :)',0Dh,0Ah
.rdata:100054A4                 db 'Copyright (c) 1998-2009 by Joergen Ibsen, All Rights Reserved.',0Dh,0Ah
.rdata:100054A4                 db 0Dh,0Ah
.rdata:100054A4                 db 'More information: http://www.ibsensoftware.com/',0Dh,0Ah
.rdata:100054A4                 db 0Dh,0Ah,0

Sweet!

Let's continue anyways...

A few variables are shuffled, and there are a couple jumps. I have no idea what it's for, but we wind up at:

seg000:003B0114                 push    edi
seg000:003B0115                 call    [ebx+test.addr_UnmapViewOfFile]

Using a debugger, I determine that edi = 350000, which is sample_safe.dll, which is my name for the original malware sample.

Basically, unload the original .dll file.

Allocate some RWX memory:

seg000:003B011E                 push    40h ; '@'       ; flProtect = PAGE_EXECUTE_READWRITE
seg000:003B0120                 push    3000h           ; flAlloctionType = MEM_COMMIT | MEM_RESERVE
seg000:003B0125                 push    eax             ; dwSize = a bit bigger than the decrypt function returned
seg000:003B0126                 push    edi             ; lpAddress = the same address that the .dll was unloaded from
seg000:003B0127                 call    [ebx+test.addr_VirtualAlloc]

Some more functions are called. I assume, based on what we've seen, that it dynamically loads the decrypted dll into memory, and does the fixups/relocs.

The non-relocated but decrypted data is freed:

seg000:003B0153                 push    dword ptr [ebp-4]
seg000:003B0156                 call    [ebx+test.addr_VirtualFree]

One more function is called, then its return value is called:

seg000:003B0174                 call    sub_3B02E5
seg000:003B0179                 pop     ebx
seg000:003B017A                 pop     edi
seg000:003B017B                 pop     esi
seg000:003B017C                 leave
seg000:003B017D                 push    8000h
seg000:003B0182                 push    0
seg000:003B0184                 push    ecx
seg000:003B0185                 push    edx
seg000:003B0186                 jmp     eax

This actually bears some attention. The program frees itself, then has VirtualFree return into edx, which is the entrypoint of the new .dll file!
