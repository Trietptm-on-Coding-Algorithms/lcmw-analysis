CAUTION.zip

hlcumrpi.date

$ file hlcumrpi.dat
hlcumrpi.dat: PE32 executable (DLL) (GUI) Intel 80386, for MS Windows

Rename to sample.bin

Check 'exports', just in case

Dump it, as-is:

.text:004014AB ; const CHAR DllEntryPoint
.text:004014AB                 public DllEntryPoint
.text:004014AB DllEntryPoint   proc near               ; DATA XREF: DllEntryPoint+13o
.text:004014AB
.text:004014AB hinstDLL        = dword ptr  4
.text:004014AB fdwReason       = dword ptr  8
.text:004014AB lpReserved      = dword ptr  0Ch
.text:004014AB
.text:004014AB                 push    esi
.text:004014AC                 push    edi
.text:004014AD                 push    ebx
.text:004014AE                 mov     ebx, 0FFFFFh
.text:004014B3
.text:004014B3 loc_4014B3:                             ; CODE XREF: DllEntryPoint+11j
.text:004014B3                 call    sub_401378
.text:004014B8                 dec     ebx
.text:004014B9                 cmp     ebx, 43h
.text:004014BC                 jnz     short loc_4014B3
.text:004014BE                 push    offset DllEntryPoint ; lpString
.text:004014C3                 call    ds:lstrlenA
.text:004014C9                 mov     ebx, 0FFFFFFh
.text:004014CE
.text:004014CE loc_4014CE:                             ; CODE XREF: DllEntryPoint+2Cj
.text:004014CE                 call    sub_4014A4
.text:004014D3                 dec     ebx
.text:004014D4                 cmp     ebx, 43h
.text:004014D7                 jnz     short loc_4014CE
.text:004014D9                 push    40h             ; flProtect
.text:004014DB                 push    3000h           ; flAllocationType
.text:004014E0                 push    30AD8h          ; dwSize
.text:004014E5                 push    0               ; lpAddress
.text:004014E7                 call    ds:VirtualAlloc
.text:004014ED                 mov     edx, eax
.text:004014EF                 mov     edi, eax
.text:004014F1                 mov     esi, offset byte_401549
.text:004014F6
.text:004014F6 loc_4014F6:                             ; CODE XREF: DllEntryPoint:loc_401518j
.text:004014F6                 call    sub_401520
.text:004014FB                 shl     al, 2
.text:004014FE                 shr     ax, 2
.text:00401502                 stosb
.text:00401503                 shl     ah, 4
.text:00401506                 shr     eax, 8
.text:00401509                 shl     ax, 2
.text:0040150D                 shr     eax, 6
.text:00401510                 stosw
.text:00401512                 cmp     esi, offset byte_43201D
.text:00401518
.text:00401518 loc_401518:                             ; CODE XREF: .text:00401556j
.text:00401518                 jbe     short loc_4014F6
.text:0040151A                 pop     ebx
.text:0040151B                 pop     edi
.text:0040151C                 pop     esi
.text:0040151D                 jmp     edx
.text:0040151D DllEntryPoint   endp

Prefix:
.text:004014AB                 push    esi
.text:004014AC                 push    edi
.text:004014AD                 push    ebx

Then useless code:

.text:004014AE                 mov     ebx, 0FFFFFh
.text:004014B3
.text:004014B3 loc_4014B3:                             ; CODE XREF: DllEntryPoint+11j
.text:004014B3                 call    UselessComplicatedFunction ; <-- call this about a million times
.text:004014B3                                         ; Honestly, I suspect this is a whole lot of nothing that's done to waste time
.text:004014B8                 dec     ebx
.text:004014B9                 cmp     ebx, 43h
.text:004014BC                 jnz     short loc_4014B3

Then more useless code:

.text:004014C3                 call    ds:lstrlenA     ; <-- get the strlen() of main(), which should be ignored

Some more delay code:

.text:004014C9                 mov     ebx, 0FFFFFFh
.text:004014CE
.text:004014CE loc_4014CE:                             ; CODE XREF: DllEntryPoint+2Cj
.text:004014CE                 call    GetCurrentProcessIdWrapper ; Call GetCurrentProcessId about a sixteen million times
.text:004014D3                 dec     ebx
.text:004014D4                 cmp     ebx, 43h
.text:004014D7                 jnz     short loc_4014CE

Then it gets interesting:

.text:004014D9                 push    PAGE_EXECUTE_READWRITE ; flProtect
.text:004014DB                 push    3000h           ; flAllocationType = MEM_COMMIT | MEM_RESERVE
.text:004014E0                 push    30AD8h          ; dwSize
.text:004014E5                 push    0               ; lpAddress
.text:004014E7                 call    ds:VirtualAlloc ; Allocate memory to store the decrypted code
.text:004014ED                 mov     edx, eax
.text:004014EF                 mov     edi, eax        ; edi => destination memory

Decrypt loop:

.text:004014F6 decrypt_loop:                           ; CODE XREF: DllEntryPoint+6Dj
.text:004014F1                 mov     esi, offset start_encrypted_code
.text:004014F6                 call    XorAndRotate    ; eax = the next 4 non-NULL bytes in esi, each XORed by ebx (0x43?)
.text:004014FB                 shl     al, 2
.text:004014FE                 shr     ax, 2
.text:00401502                 stosb
.text:00401503                 shl     ah, 4
.text:00401506                 shr     eax, 8
.text:00401509                 shl     ax, 2
.text:0040150D                 shr     eax, 6
.text:00401510                 stosw
.text:00401512                 cmp     esi, offset end_encrypted_data
.text:00401518                 jbe     short decrypt_loop

start_encrypted_code:

.text:00401549 start_encrypted_code db 0D6h, 0E6h, 1Bh, 0BAh, 0C0h, 0F1h, 0CDh, 0C2h, 0, 0D5h
.text:00401549                                         ; DATA XREF: DllEntryPoint+46o
.text:00401549                 db 5Eh, 0B6h, 97h, 0EBh, 0C0h
.text:00401558                 dd 2 dup(83008300h), 0C2D50033h, 53C02D2Dh, 0C7008300h
.text:00401558                 dd 6A78300h, 83000F49h, 83008300h, 81C88300h, 0C8C0C700h
.text:00401558                 dd 4C70081h, 810481C8h, 4E18300h, 8B6F1B04h, 0D6B68300h
.text:00401558                 dd 8CB98Ch, 830083h, 1F830083h, 0C2B79A97h, 6C001FE6h
.text:00401558                 dd 53D5004Eh, 1F2512A7h, 1FB44EE6h, 61B8300h, 681B9h, 830083h
....

The decrypt loop:

.text:00401520 ; eax = the next 4 non-NULL bytes in esi, each XORed by ebx (0x43?)
.text:00401520
.text:00401520 XorAndRotate    proc near               ; CODE XREF: DllEntryPoint:decrypt_loopp
.text:00401520                                         ; XorAndRotate+3j
.text:00401520                 lodsb                   ; mov eax, byte ptr [esi]
.text:00401521                 test    al, al
.text:00401523                 jz      short XorAndRotate ; Ignore NULL bytes
.text:00401525                 xor     al, bl
.text:00401527                 ror     eax, 8
.text:0040152A
.text:0040152A ignore_null2:                           ; CODE XREF: XorAndRotate+Dj
.text:0040152A                 lodsb                   ; mov eax, byte ptr [esi]
.text:0040152B                 test    al, al
.text:0040152D                 jz      short ignore_null2
.text:0040152F                 xor     al, bl
.text:00401531                 ror     eax, 8
.text:00401534
.text:00401534 ignore_null3:                           ; CODE XREF: XorAndRotate+17j
.text:00401534                 lodsb                   ; mov eax, byte ptr [esi]
.text:00401535                 test    al, al
.text:00401537                 jz      short ignore_null3
.text:00401539                 xor     al, bl
.text:0040153B                 ror     eax, 8
.text:0040153E
.text:0040153E ignore_null4:                           ; CODE XREF: XorAndRotate+21j
.text:0040153E                 lodsb                   ; mov eax, byte ptr [esi]
.text:0040153F                 test    al, al
.text:00401541                 jz      short ignore_null4
.text:00401543                 xor     al, bl
.text:00401545                 ror     eax, 8
.text:00401548                 retn
.text:00401548 XorAndRotate    endp

Then the call:

.text:0040151A                 pop     ebx
.text:0040151B                 pop     edi
.text:0040151C                 pop     esi
.text:0040151D                 jmp     edx

Steps to hack:

Let's hack the binary!

Step 1. Nop out the "waste time" calls, just in case

Options->General->Disassembly->Number of opcode bytes = 8

.text:004014B3 E8 C0 FE FF FF                          call    UselessComplicatedFunction ; <-- call this about a million times
.text:004014B3                                                                 ; Honestly, I suspect this is a whole lot of nothing that's done to waste time
.text:004014B8 4B                                      dec     ebx
.text:004014B9 83 FB 43             

Use "xvi32" to search for e8 c0 fe ff ff 4b 83 fb 43

Offset 0x8b3

Replace "e8 c0 fe ff ff" with "90 90 90 90 90"

Do the same for the next one:

.text:004014CE E8 D1 FF FF FF                          call    GetCurrentProcessIdWrapper ; Call GetCurrentProcessId about a sixteen million times
.text:004014D3 4B                                      dec     ebx
.text:004014D4 83 FB 43                                cmp     ebx, 43h

Offset should be 0x8ce

Step 2. Replace the final "jmp" with "int 3", to create a debug breakpoint

Find the code:

.text:00401518 76 DC                                   jbe     short decrypt_loop
.text:0040151A 5B                                      pop     ebx
.text:0040151B 5F                                      pop     edi
.text:0040151C 5E                                      pop     esi
.text:0040151D FF E2                                   jmp     edx
.text:0040151D                         DllEntryPoint   endp
.text:0040151D
.text:0040151F                         ; ---------------------------------------------------------------------------
.text:0040151F C3                                      retn

0x91d

Replace FF E2 with 

framework-trunk/tools $ ./nasm_shell.rb
nasm > int 3
00000000  CD03              int 0x3

Load it in IDA just to be safe:

.text:004014AB DllEntryPoint   proc near               ; DATA XREF: DllEntryPoint+13o
.text:004014AB
.text:004014AB hinstDLL        = dword ptr  4
.text:004014AB fdwReason       = dword ptr  8
.text:004014AB lpReserved      = dword ptr  0Ch
.text:004014AB
.text:004014AB                 push    esi
.text:004014AC                 push    edi
.text:004014AD                 push    ebx
.text:004014AE                 mov     ebx, 0FFFFFh
.text:004014B3
.text:004014B3 loc_4014B3:                             ; CODE XREF: DllEntryPoint+11j
.text:004014B3                 nop
.text:004014B4                 nop
.text:004014B5                 nop
.text:004014B6                 nop
.text:004014B7                 nop
.text:004014B8                 dec     ebx
.text:004014B9                 cmp     ebx, 43h
.text:004014BC                 jnz     short loc_4014B3
.text:004014BE                 push    offset DllEntryPoint ; lpString
.text:004014C3                 call    ds:lstrlenA
.text:004014C9                 mov     ebx, 0FFFFFFh
.text:004014CE
.text:004014CE loc_4014CE:                             ; CODE XREF: DllEntryPoint+2Cj
.text:004014CE                 nop
.text:004014CF                 nop
.text:004014D0                 nop
.text:004014D1                 nop
.text:004014D2                 nop
.text:004014D3                 dec     ebx
.text:004014D4                 cmp     ebx, 43h
.text:004014D7                 jnz     short loc_4014CE
.text:004014D9                 push    40h             ; flProtect
.text:004014DB                 push    3000h           ; flAllocationType
.text:004014E0                 push    30AD8h          ; dwSize
.text:004014E5                 push    0               ; lpAddress
.text:004014E7                 call    ds:VirtualAlloc
.text:004014ED                 mov     edx, eax
.text:004014EF                 mov     edi, eax
.text:004014F1                 mov     esi, offset byte_401549
.text:004014F6
.text:004014F6 loc_4014F6:                             ; CODE XREF: DllEntryPoint:loc_401518j
.text:004014F6                 call    sub_401520
.text:004014FB                 shl     al, 2
.text:004014FE                 shr     ax, 2
.text:00401502                 stosb
.text:00401503                 shl     ah, 4
.text:00401506                 shr     eax, 8
.text:00401509                 shl     ax, 2
.text:0040150D                 shr     eax, 6
.text:00401510                 stosw
.text:00401512                 cmp     esi, offset byte_43201D
.text:00401518
.text:00401518 loc_401518:                             ; CODE XREF: .text:00401556j
.text:00401518                 jbe     short loc_4014F6
.text:0040151A                 pop     ebx
.text:0040151B                 pop     edi
.text:0040151C                 pop     esi
.text:0040151D                 int     3               ; - software interrupt to invoke the debugger
.text:0040151F                 retn
.text:0040151F DllEntryPoint   endp

Step 3. Create a .exe that loads the .dll

#include <windows.h>

int main(int argc, char *argv[])
{
	LoadLibrary("C:\\Documents and Settings\\Administrator\\Desktop\\sample_safe.bin");

	return 0;
}

Step 4. Run that .exe in a controlled way

C:\Program Files\Debugging Tools for Windows (x86)>windbg "c:\Documents and Sett
ings\Administrator\My Documents\Visual Studio 2008\Projects\test_malware\Debug\t
est_malware.exe"

Executable search path is: 
ModLoad: 00400000 0041b000   test_malware.exe
ModLoad: 7c800000 7c8c0000   ntdll.dll
ModLoad: 77e40000 77f42000   C:\WINDOWS\system32\kernel32.dll
ModLoad: 10200000 10323000   C:\WINDOWS\WinSxS\x86_Microsoft.VC90.DebugCRT_1fc8b3b9a1e18e3b_9.0.21022.8_x-ww_597C3456\MSVCR90D.dll
(1b8.2d4): Break instruction exception - code 80000003 (first chance)
eax=10400000 ebx=7ffda000 ecx=00000003 edx=00000008 esi=7c8877f4 edi=00151f38
eip=7c81a3e1 esp=0012fb70 ebp=0012fcb4 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for ntdll.dll - 
ntdll!DbgBreakPoint:
7c81a3e1 cc              int     3
0:000> g
ModLoad: 00350000 00389000   C:\Documents and Settings\Administrator\Desktop\sample_safe.bin
ModLoad: 77380000 77411000   C:\WINDOWS\system32\user32.dll
ModLoad: 77c00000 77c48000   C:\WINDOWS\system32\GDI32.dll
ModLoad: 77f50000 77feb000   C:\WINDOWS\system32\ADVAPI32.dll
ModLoad: 77c50000 77cef000   C:\WINDOWS\system32\RPCRT4.dll
ModLoad: 76f50000 76f63000   C:\WINDOWS\system32\Secur32.dll
(1b8.2d4): Break instruction exception - code 80000003 (first chance)
eax=00035000 ebx=003514ab ecx=77e64590 edx=003b0000 esi=0012f7d0 edi=00000001
eip=0035151e esp=0012f7c0 ebp=0012f7dc iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
*** ERROR: Module load completed but symbols could not be loaded for C:\Documents and Settings\Administrator\Desktop\sample_safe.bin
sample_safe+0x151e:
0035151e 03c3            add     eax,ebx

Step 5. Dump the memory

We know that edx points to the memory...

Verify:

0:000> u edx
003b0000 55              push    ebp
003b0001 89e5            mov     ebp,esp
003b0003 83ec04          sub     esp,4
003b0006 56              push    esi
003b0007 57              push    edi
003b0008 53              push    ebx
003b0009 e800000000      call    003b000e
003b000e 5b              pop     ebx

Looks good! Now write the memory to a file:

0:000> .writemem c:\\stage2.bin 0x3b0000 L0x30AD8
Writing 30ad8 bytes..................................................................................................

Load the file into IDA..

seg000:00000000                 push    ebp
seg000:00000001                 mov     ebp, esp
seg000:00000003                 sub     esp, 4
seg000:00000006                 push    esi
seg000:00000007                 push    edi
seg000:00000008                 push    ebx
seg000:00000009                 call    $+5
seg000:0000000E                 pop     ebx
seg000:0000000F                 sub     ebx, 40100Eh
...

Looks good!

First ~1000 bytes look like code, but the rest looks encrypted again!

Last ~1/3 is all zeroes
